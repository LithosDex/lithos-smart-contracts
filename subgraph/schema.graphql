type Factory @entity(immutable: false) {
  # Factory address
  id: ID!

  # Total number of pairs created
  pairCount: Int!

  # Total volume in USD
  totalVolumeUSD: BigDecimal!

  # Total volume in ETH
  totalVolumeETH: BigDecimal!

  # Total liquidity in USD
  totalLiquidityUSD: BigDecimal!

  # Total liquidity in ETH
  totalLiquidityETH: BigDecimal!

  # Total transaction count
  txCount: BigInt!

  # Fee settings
  stableFee: BigInt!
  volatileFee: BigInt!
  stakingNFTFee: BigInt!
  maxReferralFee: BigInt!

  # Addresses
  pauser: Bytes!
  feeManager: Bytes!
  dibs: Bytes
  stakingFeeHandler: Bytes

  # Pause state
  isPaused: Boolean!

  # All pairs created by this factory
  pairs: [Pair!]! @derivedFrom(field: "factory")
}

type Token @entity(immutable: false) {
  # Token address
  id: ID!

  # Token info
  symbol: String!
  name: String!
  decimals: BigInt!

  # Price tracking
  derivedETH: BigDecimal! # Token price in ETH
  # Volume and liquidity
  tradeVolume: BigDecimal!
  tradeVolumeUSD: BigDecimal!
  totalLiquidity: BigDecimal!

  # Transaction count
  txCount: BigInt!

  # Pairs this token is part of
  pairBase: [Pair!]! @derivedFrom(field: "token0")
  pairQuote: [Pair!]! @derivedFrom(field: "token1")

  # Token day data
  tokenDayData: [TokenDayData!]! @derivedFrom(field: "token")
}

type Pair @entity(immutable: false) {
  # Pair address
  id: ID!

  # Factory that created this pair
  factory: Factory!

  # Tokens in the pair
  token0: Token!
  token1: Token!

  # Pair type (stable or volatile)
  stable: Boolean!

  # Reserves
  reserve0: BigDecimal!
  reserve1: BigDecimal!

  # Total supply of LP tokens
  totalSupply: BigDecimal!

  # Derived liquidity
  reserveETH: BigDecimal!
  reserveUSD: BigDecimal!

  # Cumulative values for TWAP
  reserve0CumulativeLast: BigInt!
  reserve1CumulativeLast: BigInt!

  # Price tracking
  token0Price: BigDecimal!
  token1Price: BigDecimal!

  # Volume
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!

  # Transaction counts
  txCount: BigInt!

  # Fees
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!
  referralFeesToken0: BigDecimal!
  referralFeesToken1: BigDecimal!
  referralFeesUSD: BigDecimal!
  stakingFeesToken0: BigDecimal!
  stakingFeesToken1: BigDecimal!
  stakingFeesUSD: BigDecimal!

  # Fee indexes for tracking
  index0: BigDecimal!
  index1: BigDecimal!

  # Creation
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # Last update
  lastUpdateTimestamp: BigInt!
  lastUpdateBlockNumber: BigInt!

  # Gauge associated with this pair (if any)
  gauge: Gauge

  # Derived fields
  mints: [Mint!]! @derivedFrom(field: "pair")
  burns: [Burn!]! @derivedFrom(field: "pair")
  swaps: [Swap!]! @derivedFrom(field: "pair")
  liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "pair")
  pairHourData: [PairHourData!]! @derivedFrom(field: "pair")
  pairDayData: [PairDayData!]! @derivedFrom(field: "pair")
  pairEpochData: [PairEpochData!]! @derivedFrom(field: "pair")
  gaugeEpochVotes: [GaugeEpochVote!]! @derivedFrom(field: "pair")
  bribeEpochRewards: [PairBribeEpochReward!]! @derivedFrom(field: "pair")

  # Observations for TWAP
  observations: [Observation!]! @derivedFrom(field: "pair")
}

type User @entity(immutable: false) {
  # User address
  id: ID!

  # Liquidity positions
  liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "user")

  # USD swapped
  usdSwapped: BigDecimal!

  # VotingEscrow related fields
  veNFTCount: BigInt!
  totalLocked: BigDecimal!
  delegatedTo: String
  delegatedVotingPower: BigInt!

  # Derived fields for VotingEscrow
  veNFTs: [VeNFT!]! @derivedFrom(field: "owner")
  veDeposits: [VeDeposit!]! @derivedFrom(field: "user")
  veWithdraws: [VeWithdraw!]! @derivedFrom(field: "user")
  veTransfersTo: [VeTransfer!]! @derivedFrom(field: "toUser")
  veDelegations: [VeDelegation!]! @derivedFrom(field: "delegator")
}

type LiquidityPosition @entity(immutable: false) {
  # User address + Pair address
  id: ID!

  # User and pair
  user: User!
  pair: Pair!

  # LP token balance
  liquidityTokenBalance: BigDecimal!

  # Snapshots of token balances
  liquidityPositionSnapshots: [LiquidityPositionSnapshot!]!
    @derivedFrom(field: "liquidityPosition")

  # Fee tracking
  supplyIndex0: BigDecimal!
  supplyIndex1: BigDecimal!
  claimable0: BigDecimal!
  claimable1: BigDecimal!
}

type LiquidityPositionSnapshot @entity(immutable: false) {
  # Position ID + timestamp
  id: ID!

  # Position reference
  liquidityPosition: LiquidityPosition!

  # Timestamp
  timestamp: Int!
  block: Int!

  # User and pair
  user: User!
  pair: Pair!

  # Token amounts
  token0PriceUSD: BigDecimal!
  token1PriceUSD: BigDecimal!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  reserveUSD: BigDecimal!
  liquidityTokenTotalSupply: BigDecimal!
  liquidityTokenBalance: BigDecimal!
}

type Transaction @entity(immutable: false) {
  # Transaction hash
  id: ID!

  # Block number and timestamp
  blockNumber: BigInt!
  timestamp: BigInt!

  # Gas used
  gasUsed: BigInt!
  gasPrice: BigInt!

  # Derived fields
  mints: [Mint!]! @derivedFrom(field: "transaction")
  burns: [Burn!]! @derivedFrom(field: "transaction")
  swaps: [Swap!]! @derivedFrom(field: "transaction")
}

type Mint @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction
  transaction: Transaction!

  # Timestamp
  timestamp: BigInt!

  # Pair
  pair: Pair!

  # Sender
  to: Bytes!

  # Liquidity
  liquidity: BigDecimal!

  # Token amounts
  amount0: BigDecimal!
  amount1: BigDecimal!

  # USD amount
  amountUSD: BigDecimal

  # Derived from transaction
  sender: Bytes # Address that initiated the transaction
  # Log index in transaction
  logIndex: BigInt
}

type Burn @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction
  transaction: Transaction!

  # Timestamp
  timestamp: BigInt!

  # Pair
  pair: Pair!

  # Liquidity
  liquidity: BigDecimal!

  # Token amounts
  amount0: BigDecimal!
  amount1: BigDecimal!

  # USD amount
  amountUSD: BigDecimal

  # To address
  to: Bytes!

  # Derived from transaction
  sender: Bytes # Address that initiated the transaction
  # Log index in transaction
  logIndex: BigInt
}

type Swap @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction
  transaction: Transaction!

  # Timestamp
  timestamp: BigInt!

  # Pair
  pair: Pair!

  # Sender and recipient
  sender: Bytes!
  to: Bytes!

  # Token amounts
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!

  # USD amounts
  amountUSD: BigDecimal!

  # Price after swap
  token0PriceUSD: BigDecimal!
  token1PriceUSD: BigDecimal!

  # Log index in transaction
  logIndex: BigInt
}

type RouterSwap @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction
  transaction: Transaction!

  # Timestamp
  timestamp: BigInt!

  # Router details
  sender: Bytes!
  to: Bytes!

  # Token details
  tokenIn: Bytes!
  amountIn: BigDecimal!

  # Pool type
  stable: Boolean!

  # USD amount
  amountUSD: BigDecimal

  # Log index in transaction
  logIndex: BigInt
}

type Observation @entity(immutable: false) {
  # Pair address + timestamp
  id: ID!

  # Pair reference
  pair: Pair!

  # Timestamp
  timestamp: BigInt!

  # Cumulative reserves
  reserve0Cumulative: BigInt!
  reserve1Cumulative: BigInt!

  # Block
  blockNumber: BigInt!
}

type Bundle @entity(immutable: false) {
  # Always "1"
  id: ID!

  # Price of ETH in USD
  ethPrice: BigDecimal!
}

# Hourly data
type PairHourData @entity(immutable: false) {
  # Pair address + hour timestamp
  id: ID!

  # Hour timestamp
  hourStartUnix: Int!

  # Pair reference
  pair: Pair!

  # Reserves
  reserve0: BigDecimal!
  reserve1: BigDecimal!

  # Derived amounts
  reserveUSD: BigDecimal!

  # Volume
  hourlyVolumeToken0: BigDecimal!
  hourlyVolumeToken1: BigDecimal!
  hourlyVolumeUSD: BigDecimal!

  # Transaction count
  hourlyTxns: BigInt!
}

type PairDayData @entity(immutable: false) {
  # Pair address + day timestamp
  id: ID!

  # Day timestamp
  date: Int!

  # Pair reference
  pair: Pair!

  # Token references
  token0: Token!
  token1: Token!

  # Reserves
  reserve0: BigDecimal!
  reserve1: BigDecimal!

  # Total supply
  totalSupply: BigDecimal!

  # Derived amounts
  reserveUSD: BigDecimal!

  # Volume
  dailyVolumeToken0: BigDecimal!
  dailyVolumeToken1: BigDecimal!
  dailyVolumeUSD: BigDecimal!

  # Transaction count
  dailyTxns: BigInt!
}

type PairEpochData @entity(immutable: false) {
  # Pair address + epoch timestamp
  id: ID!

  # Epoch info (start timestamp truncated to week)
  epoch: BigInt!
  epochStart: BigInt!
  epochEnd: BigInt!

  # Pair reference
  pair: Pair!

  # Token references
  token0: Token!
  token1: Token!

  # Fees attributed to LPs
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!

  # Volume within this epoch
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!

  # Referral fee share
  referralFeesToken0: BigDecimal!
  referralFeesToken1: BigDecimal!
  referralFeesUSD: BigDecimal!

  # Staking fee share
  stakingFeesToken0: BigDecimal!
  stakingFeesToken1: BigDecimal!
  stakingFeesUSD: BigDecimal!

  # Last update
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type TokenDayData @entity(immutable: false) {
  # Token address + day timestamp
  id: ID!

  # Day timestamp
  date: Int!

  # Token reference
  token: Token!

  # Volume
  dailyVolumeToken: BigDecimal!
  dailyVolumeETH: BigDecimal!
  dailyVolumeUSD: BigDecimal!

  # Transaction count
  dailyTxns: BigInt!

  # Total liquidity
  totalLiquidityToken: BigDecimal!
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!

  # Price
  priceUSD: BigDecimal!
}

type PlasmaSwapDayData @entity(immutable: false) {
  # Day timestamp
  id: ID!

  # Day timestamp
  date: Int!

  # Volume
  dailyVolumeETH: BigDecimal!
  dailyVolumeUSD: BigDecimal!

  # Transaction count
  dailyTxns: BigInt!

  # Total liquidity
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!

  # Most liquid tokens
  mostLiquidTokens: [TokenDayData!]!
}

# ===== VOTING ESCROW ENTITIES =====

type VotingEscrow @entity(immutable: false) {
  # VotingEscrow contract address
  id: ID!

  # Contract address
  address: Bytes!

  # Total supply of locked tokens
  totalSupply: BigInt!

  # Total locked amount across all NFTs
  totalLocked: BigInt!

  # Total number of veNFTs created
  totalNFTs: BigInt!

  # All veNFTs from this contract
  veNFTs: [VeNFT!]! @derivedFrom(field: "votingEscrow")
}

type VeNFT @entity(immutable: false) {
  # Token ID as string
  id: ID!

  # Token ID as BigInt
  tokenId: BigInt!

  # VotingEscrow contract
  votingEscrow: VotingEscrow!

  # Current owner
  owner: User!

  # Locked token amount
  value: BigInt!

  # Lock end timestamp
  lockEnd: BigInt!

  # Lock duration in seconds
  lockDuration: BigInt!

  # Delegation target
  delegatedTo: User

  # Creation timestamp
  createdAt: BigInt!

  # Last update timestamp
  updatedAt: BigInt!

  # Whether NFT is still active (not withdrawn)
  isActive: Boolean!

  # Derived fields
  deposits: [VeDeposit!]! @derivedFrom(field: "veNFT")
  transfers: [VeTransfer!]! @derivedFrom(field: "veNFT")
}

type VeDeposit @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction hash
  transaction: Bytes!

  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!

  # User who deposited
  user: User!

  # veNFT involved
  veNFT: VeNFT!

  # VotingEscrow contract
  votingEscrow: VotingEscrow!

  # Deposited amount
  value: BigInt!

  # Lock end time
  locktime: BigInt!

  # Deposit type (CREATE_LOCK, INCREASE_AMOUNT, etc.)
  depositType: Int!
}

type VeWithdraw @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction hash
  transaction: Bytes!

  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!

  # User who withdrew
  user: User!

  # veNFT involved (as string since NFT might be deleted)
  veNFTId: String!

  # VotingEscrow contract
  votingEscrow: VotingEscrow!

  # Withdrawn amount
  value: BigInt!
}

type VeTransfer @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction hash
  transaction: Bytes!

  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!

  # Transfer details
  fromUser: User
  toUser: User
  fromAddress: String!
  toAddress: String!

  # veNFT transferred
  veNFT: VeNFT!
}

type VeDelegation @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction hash
  transaction: Bytes!

  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!

  # Delegation details
  delegator: User!
  fromDelegate: String!
  toDelegate: String!
}

# ===== MINTER ENTITIES =====

type Minter @entity(immutable: false) {
  # Minter contract address
  id: ID!
  
  # Contract address
  address: Bytes!
  
  # Total emissions minted
  totalEmissions: BigInt!
  
  # Current weekly emission
  currentWeeklyEmission: BigInt!
  
  # Number of mint events
  mintCount: BigInt!
  
  # Current period
  activePeriod: BigInt!
  
  # Emission parameters
  emissionRate: BigInt! # EMISSION parameter
  tailEmissionRate: BigInt! # TAIL_EMISSION parameter
  teamRate: BigInt!
  
  # Last mint timestamp
  lastMintTimestamp: BigInt!
  
  # All mint events from this contract
  mintEvents: [MintEvent!]! @derivedFrom(field: "minter")
}

type MintEvent @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Minter contract
  minter: Minter!
  
  # User who triggered the mint (called update_period)
  sender: User!
  
  # Emission data from event
  weeklyEmission: BigInt!
  circulatingSupply: BigInt!
  circulatingEmission: BigInt!
  
  # Calculated fields
  period: BigInt! # The period this mint corresponds to
}

# ===== BRIBE FACTORY ENTITIES =====

type BribeFactory @entity(immutable: false) {
  # BribeFactory contract address
  id: ID!
  
  # Contract address
  address: Bytes!
  
  # Associated contracts
  voter: Bytes! # VoterV3 contract
  permissionsRegistry: Bytes! # Permissions registry
  
  # Factory statistics
  totalBribesCreated: BigInt! # Total number of bribes created
  lastBribe: Bytes! # Address of the last created bribe
  
  # Default reward tokens for new bribes
  defaultRewardTokenCount: BigInt!
  
  # All bribes created by this factory
  bribes: [Bribe!]! @derivedFrom(field: "factory")
}

# ===== VOTER ENTITIES =====

type Voter @entity(immutable: false) {
  # VoterV3 contract address
  id: ID!
  
  # Contract address
  address: Bytes!
  
  # Associated factories
  gaugeFactory: Bytes!
  bribeFactory: Bytes!
  
  # Associated contracts
  minter: Bytes!
  votingEscrow: Bytes!
  
  # Voting statistics
  totalGaugesCreated: BigInt!
  totalPoolsWithGauges: BigInt!
  
  # All gauges created by this voter
  gauges: [Gauge!]! @derivedFrom(field: "voter")
}

type GaugeCreatedEvent @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Voter contract
  voter: Voter!
  
  # Created gauge
  gauge: Gauge!
  
  # Pool token (LP token)
  poolToken: Token!
  
  # Created bribes
  internalBribe: Bribe!
  externalBribe: Bribe!
}

# ===== BRIBES ENTITIES =====

type Bribe @entity(immutable: false) {
  # Bribe contract address
  id: ID!
  
  # Contract address
  address: Bytes!
  
  # Bribe type (internal/external)
  type: String!
  
  # Factory that created this bribe
  factory: BribeFactory!
  
  # Associated contracts
  voter: Bytes!
  minter: Bytes!
  bribeFactory: Bytes!
  gauge: Gauge
  pair: Pair
  
  # Owner
  owner: User!
  
  # Total voting power across all epochs
  totalVotingPower: BigInt!
  
  # Number of reward tokens
  rewardTokenCount: BigInt!
  
  # All reward tokens for this bribe
  rewardTokens: [BribeRewardToken!]! @derivedFrom(field: "bribe")
  
  # All reward events
  rewardEvents: [BribeRewardAdded!]! @derivedFrom(field: "bribe")
  
  # All stake events
  stakeEvents: [BribeStake!]! @derivedFrom(field: "bribe")
  
  # All withdraw events
  withdrawEvents: [BribeWithdraw!]! @derivedFrom(field: "bribe")
  
  # All reward payment events
  rewardPayments: [BribeRewardPaid!]! @derivedFrom(field: "bribe")

  # Epoch-level reward aggregates
  epochRewards: [BribeEpochReward!]! @derivedFrom(field: "bribe")
  epochStakeTotals: [BribeEpochStake!]! @derivedFrom(field: "bribe")

  # Epoch-level vote aggregates
  epochVotes: [GaugeEpochVote!]! @derivedFrom(field: "bribe")
  pairEpochRewards: [PairBribeEpochReward!]! @derivedFrom(field: "bribe")
}

type BribeRewardToken @entity(immutable: false) {
  # Bribe address + token address
  id: ID!
  
  # Bribe contract
  bribe: Bribe!
  
  # Reward token
  token: Token!
  
  # Total rewards added across all epochs
  totalRewards: BigInt!
  
  # Number of epochs with rewards
  epochCount: BigInt!
  
  # Is currently active reward token
  isActive: Boolean!
  
  # All reward additions for this token
  rewardAdditions: [BribeRewardAdded!]! @derivedFrom(field: "rewardToken")
  
  # Epoch-level reward aggregates for this token
  epochRewards: [BribeEpochReward!]! @derivedFrom(field: "rewardToken")
}

type BribeRewardAdded @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Bribe contract
  bribe: Bribe!
  
  # Reward token entity
  rewardToken: BribeRewardToken!
  
  # Raw reward token address
  rewardTokenAddress: Bytes!
  
  # Reward amount
  reward: BigInt!
  
  # Start timestamp (epoch when rewards become available)
  startTimestamp: BigInt!
  
  # Calculated epoch
  epoch: BigInt!
}

type BribeStake @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!

  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Bribe contract
  bribe: Bribe!

  # veNFT that was staked
  veNFT: VeNFT!

  # Aggregate stake record for this bribe/epoch
  epochStake: BribeEpochStake

  # Voting power amount
  amount: BigInt!

  # Epoch this stake applies to
  epoch: BigInt!
}

type BribeEpochStake @entity(immutable: false) {
  # Bribe address + epoch
  id: ID!

  bribe: Bribe!
  epoch: BigInt!
  totalWeight: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  veStakes: [BribeEpochVeStake!]! @derivedFrom(field: "epochStake")
}

type BribeEpochVeStake @entity(immutable: false) {
  # Bribe + epoch + veNFT
  id: ID!

  epochStake: BribeEpochStake!
  bribe: Bribe!
  veNFT: VeNFT!
  epoch: BigInt!
  weight: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type BribeWithdraw @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Bribe contract
  bribe: Bribe!
  
  # veNFT that was withdrawn
  veNFTId: BigInt!
  
  # Voting power amount withdrawn
  amount: BigInt!
  
  # Epoch this withdrawal affects
  epoch: BigInt!
}

type BribeRewardPaid @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Bribe contract
  bribe: Bribe!
  
  # User who received the reward
  user: User!
  
  # Reward token address
  rewardTokenAddress: Bytes!
  
  # Reward amount
  reward: BigInt!
}

type BribeEpochReward @entity(immutable: false) {
  # Bribe address + reward token address + epoch
  id: ID!
  
  # Bribe contract
  bribe: Bribe!
  
  # Reward token entity
  rewardToken: BribeRewardToken!
  
  # Epoch info
  epoch: BigInt!
  epochStart: BigInt!
  epochEnd: BigInt!
  
  # Aggregate reward amount for the epoch
  reward: BigInt!
  
  # Last update info
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type PairBribeEpochReward @entity(immutable: false) {
  # Pair address + epoch + reward token
  id: ID!

  pair: Pair!
  gauge: Gauge
  bribe: Bribe!
  rewardToken: Token!
  isInternal: Boolean!

  epoch: BigInt!
  epochStart: BigInt!
  epochEnd: BigInt!

  reward: BigInt!

  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type GaugeEpochVote @entity(immutable: false) {
  # Gauge address + epoch timestamp
  id: ID!
  
  # Gauge/Bribe context
  gauge: Gauge!
  bribe: Bribe!
  pair: Pair!
  
  # Epoch timing
  epoch: BigInt!
  epochStart: BigInt!
  epochEnd: BigInt!
  
  # Total vote weight for this epoch
  totalWeight: BigInt!
  
  # Last update metadata
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type TokenGaugeEpochVote @entity(immutable: false) {
  # tokenId + gauge + epoch
  id: ID!
  
  tokenId: BigInt!
  gauge: Gauge!
  bribe: Bribe!
  pair: Pair!
  
  epoch: BigInt!
  epochStart: BigInt!
  epochEnd: BigInt!
  
  weight: BigInt!
  
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

type TokenEpochVoting @entity(immutable: false) {
  # tokenId + epoch
  id: ID!
  
  tokenId: BigInt!
  epoch: BigInt!
  pools: [String!]!
  
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
}

# ===== GAUGE ENTITIES =====

type Gauge @entity(immutable: false) {
  # Gauge contract address
  id: ID!
  
  # Contract address
  address: Bytes!
  
  # Voter that created this gauge
  voter: Voter!
  
  # Associated contracts
  rewardToken: Token!  # Main reward token (usually protocol token)
  stakingToken: Token! # LP token or other stakeable token
  votingEscrow: Bytes! # VE contract address
  distribution: Bytes! # VoterV3 contract address
  # Pair this gauge is associated with (if staking LP tokens)
  pair: Pair

  # Bribe contracts
  internalBribe: Bribe! # Internal bribe (receives fees)
  externalBribe: Bribe! # External bribe (receives incentives)
  
  # Gauge properties
  isForPair: Boolean! # Whether this gauge is for a trading pair
  emergency: Boolean! # Emergency mode status
  
  # Staking totals
  totalStaked: BigInt! # Total LP tokens staked
  totalRewardsDistributed: BigInt! # Total rewards distributed
  
  # Reward rate and timing
  rewardRate: BigInt! # Current reward rate per second
  periodFinish: BigInt! # When current reward period ends
  lastUpdateTime: BigInt! # Last reward calculation update
  
  # Gauge rewarder (additional rewards)
  gaugeRewarder: Bytes
  
  # All deposits to this gauge
  deposits: [GaugeDeposit!]! @derivedFrom(field: "gauge")
  
  # All withdrawals from this gauge
  withdrawals: [GaugeWithdraw!]! @derivedFrom(field: "gauge")
  
  # All reward distributions to this gauge
  rewardAdditions: [GaugeRewardAdded!]! @derivedFrom(field: "gauge")
  
  # All harvest events from this gauge
  harvests: [GaugeHarvest!]! @derivedFrom(field: "gauge")
  
  # All fee claims by this gauge
  feeClaims: [GaugeFeeClaim!]! @derivedFrom(field: "gauge")
  epochVotes: [GaugeEpochVote!]! @derivedFrom(field: "gauge")
  bribeEpochRewards: [PairBribeEpochReward!]! @derivedFrom(field: "gauge")
}

type GaugePosition @entity(immutable: false) {
  # Gauge address + User address
  id: ID!
  
  # Gauge and user
  gauge: Gauge!
  user: User!
  
  # Position details
  stakedBalance: BigInt! # Current staked amount
  rewardDebt: BigInt! # Reward debt for reward calculations
  pendingRewards: BigInt! # Unclaimed rewards
  
  # Totals
  totalDeposited: BigInt! # Lifetime deposits
  totalWithdrawn: BigInt! # Lifetime withdrawals
  totalRewardsClaimed: BigInt! # Lifetime rewards claimed
  
  # Last interaction
  lastDepositTime: BigInt!
  lastWithdrawTime: BigInt!
  lastHarvestTime: BigInt!
}

type GaugeDeposit @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # User who deposited
  user: User!
  
  # Deposit amount
  amount: BigInt!
}

type GaugeWithdraw @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # User who withdrew
  user: User!
  
  # Withdrawal amount
  amount: BigInt!
  
  # Whether this was an emergency withdrawal
  isEmergency: Boolean!
}

type GaugeRewardAdded @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # Reward amount added
  reward: BigInt!
  
  # New reward rate
  newRewardRate: BigInt!
  
  # Period finish time
  periodFinish: BigInt!
}

type GaugeHarvest @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # User who harvested
  user: User!
  
  # Reward amount harvested
  reward: BigInt!
}

type GaugeFeeClaim @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # Address that triggered the claim (usually the gauge itself)
  from: Bytes!
  
  # Fee amounts claimed from the underlying pair
  claimed0: BigInt! # Token0 fees
  claimed1: BigInt! # Token1 fees
}

type GaugeEmergencyEvent @entity(immutable: false) {
  # Transaction hash + log index
  id: ID!
  
  # Transaction hash
  transaction: Bytes!
  
  # Block data
  timestamp: BigInt!
  blockNumber: BigInt!
  
  # Gauge contract
  gauge: Gauge!
  
  # Event type (activated or deactivated)
  eventType: String! # "activated" or "deactivated"
}
